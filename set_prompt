#! /usr/bin/env sh
# (C) Martin V\"ath <martin@mvath.de>

name='set_prompt'
config_file="${name}.config"

Echo() {
	printf '%s\n' "${*}"
}

Echon() {
	printf '%s' "${*}"
}

zsh_escape="`printf '\033'`"
bash_escape='\e'

zsh_charseven="`printf '\007'`"
bash_charseven='\007'

zsh_backslash='\'
bash_backslash='\\'

Color() {
	if ${zsh_readable}
	then	Echon "\$${1}"
	else	Echon "${escape}${2}"
	fi
}

# Colors and attributes which can be used in configuration.
# You must first specify colors and then other attributes.

black='`Color "{fg_no_bold[black]}" "[0;30m"`'
blue='`Color "{fg_no_bold[blue]}" "[0;34m"`'
green='`Color "{fg_no_bold[green]}" "[0;32m"`'
cyan='`Color "{fg_no_bold[cyan]}" "[0;36m"`'
red='`Color "{fg_no_bold[red]}" "[0;31m"`'
purple='`Color "{fg_no_bold[magenta]}" "[0;35m"`'
brown='`Color "{fg_no_bold[yellow]}" "[0;33m"`'
lightgray='`Color "{fg_no_bold[white]}" "[0;37m"`'
darkgray='`Color "{fg_bold[black]}" "[1;30m"`'
lightblue='`Color "{fg_bold[blue]}" "[1;34m"`'
lightgreen='`Color "{fg_bold[green]}" "[1;32m"`'
lightcyan='`Color "{fg_bold[cyan]}" "[1;36m"`'
lightred='`Color "{fg_bold[red]}" "[1;31m"`'
lightpurple='`Color "{fg_bold[magenta]}" "[1;35m"`'
yellow='`Color "{fg_bold[yellow]}" "[1;33m"`'
white='`Color "{fg_bold[white]}" "[1;37m"`'

backblack='`Color "{bg[black]}" "[40m"`'
backblue='`Color "{bg[blue]}" "[44m"`'
backgreen='`Color "{bg[green]}" "[42m"`'
backcyan='`Color "{bg[cyan]}" "[46m"`'
backred='`Color "{bg[red]}" "[41m"`'
backpurple='`Color "{bg[magenta]}" "[45m"`'
backbrown='`Color "{bg[yellow]}" "[43m"`'
backlightgray='`Color "{bg[white]}" "[47m"`'

default='`Color "{reset_color}" "[0m"`'
bold='`Color "{bold_color}" "[1m"`'
faint='`Color "{escape}\${color[faint]}m" "[2m"`'
standout='`Color "{escape}\${color[standout]}m" "[3m"`'
underline='`Color "{escape}\${color[underline]}m" "[4m"`'
blink='`Color "{escape}\${color[blink]}m" "[5m"`'
reverse='`Color "{escape}\${color[reverse]}m" "[7m"`'
conceal='`Color "{escape}\${color[conceal]}m" "[8m"`'

# The default configuration:

text_at='@'
text_dots='...'
text_vcsbranchsep=':'
text_vcsstatussep=':'
text_trail=' '

# Colors for the configuration:

color_user="${brown}"
color_at="${cyan}"
color_host_normal="${green}"
color_host_ssh="${lightred}"
color_separator="${cyan}"
color_errstatus="${lightred}"
color_errbrace="${brown}"
color_vcsbranchsep="${color_at}"
color_vcsbranch="${lightpurple}"
color_vcsstatussep="${color_at}"
color_vcsstatus="${red}"
color_vcsend="${default}"
color_dir="${lightgreen}"
color_dots="${blue}"
color_prompt="${yellow}"
color_trail="${default}"
color_endall=''

# All the above color_* variables must be listed here (without prefix color_)
# If you add color variables in the configuration, you must also add them
# to this list: You can use them in indirect variables with prefix col_

color_vars='user
at
host_normal
host_ssh
separator
errstatus
errbrace
vcsbranchsep
vcsbranch
vcsstatussep
vcsstatus
vcsend
dir
dots
prompt
trail
endall'

# Configuration indirect variables (can use col_ or stripped zsh/bash variables)

hstatus_status='%(?..:%?)'
sstatus_status='%(?.. %?)'
ps_status='%(?..${col_errbrace}(${col_errstatus}%?${col_errbrace}%))'

# Other indirect variables

starthstatus='${escape}]0;'
endhstatus='${charseven}'
startsstatus='${escape}k'
endsstatus='${escape}${backslash}'

# List of indirect variables. The list can be modified in configuration.

indirect_vars='hstatus_status
sstatus_status
ps_status
starthstatus
endhstatus
startsstatus
endsstatus'

# Prompt escapes:

zsh_ps_open='%{'
zsh_ps_close='%}'
zsh_ps_dir='%~'
zsh_ps_user='%n'
zsh_ps_host='%m'
zsh_ps_prompt='%#'

bash_ps_open='\['
bash_ps_close='\]'
bash_ps_dir='\w'
bash_ps_user='\u'
bash_ps_host='\h'
bash_ps_prompt='\$'

# The following variables will be stripped from their zsh_ or bash_ prefix,
# depending on the calling mode:

strip_vars='escape
charseven
backslash
ps_open
ps_close
ps_dir
ps_user
ps_host
ps_prompt'

Usage() {
	Echo \
"Usage: temp=\"\$(${name} [options] [args for ${config_file}]; echo X)\" "'\
    && PS1="${temp%X}" ; [ -z "${ZSH_NAME}" ] || setopt promptsubst'"
options:
-b Output for bash instead of zsh (implies -VE)
-r Use readable (non-binary) output. For zsh, this prompt usually requires:
   autoload -Uz colors && colors
   escape=\$'\\033'; charseven=\$'\\007'; backslash='\\'
-C No colorized prompt
-s Use screen statusline (even if TERM is not in the supported list)
-x Use hardstatus line (even if TERM is not in the supported list)
-S Do not use screen statusline
-X No hardstatus line
-v Support VCSBRANCH/VCSSTATUS (even with -b)
-V Do not support VCSBRANCH/VCSSTATUS
-E Do not show error status
-h Show this help text
-e TEXT   Use extra TEXT (instead of separator)
-c FILE   Source FILE instead of ${config_file}; empty value skips sourcing
-l MAXLEN Allow directory path to grow maximal to MAXLEN (0 means no limit)
-L LEFT   Keep at least LEFT characters of directory path before the dots
--        last option" >&2
	exit ${1:-1}
}

readable=false
color=:
zsh=:
skipstatus=false
separator=':'
softstatus=''
hardstatus=''
vcs=':'
maxlen=24
leftkeep=8
unset extra_text
OPTIND=1
while getopts 'rEe:sSxXCbvVl:L:c:hH?' arg
do	case "${arg}" in
	r)	readable=:;;
	E)	skipstatus=:;;
	e)	extra_text="${OPTARG}";;
	s)	softstatus=:;;
	S)	softstatus=false;;
	x)	hardstatus=:;;
	X)	hardstatus=false;;
	C)	color=false;;
	b)	zsh=false
		vcs=false;;
	v)	vcs=:;;
	V)	vcs=false;;
	l)	maxlen="${OPTARG}";;
	L)	leftkeep="${OPTARG}";;
	c)	config_file="${OPTARG}";;
	*)	Usage;;
	esac
done
shift $(( ${OPTIND} - 1 ))

# We define some functions early so that they can be used/modified in the
# configuration if required.

StripVars() {
	if ${zsh}
	then	prevar='zsh_'
	else	prevar='bash_'
	fi
	for var in ${strip_vars}
	do	eval "${var}=\"\${${prevar}${var}}\""
	done
}

ColorVars() {
	for var in ${color_vars}
	do	eval "if ${color} && [ -n \"\${color_${var}}\" ]
		then	eval \"color_${var}=\\\"\${color_${var}}\\\"\"
			col_${var}=\"\${ps_open}\${color_${var}}\${ps_close}\"
		else	col_${var}=''
		fi"
	done
}

IndirectVars() {
	for var in ${indirect_vars}
	do	eval "eval \"${var}=\\\"\${${var}}\\\"\""
	done
}

# The wrapper for the above three functions.
# If sourced from zsh, we must make sure that the variable lists are
# indeed expanded, so we must switch on emulation mode.

HandleVars() {
	[ -n "${ZSH_NAME}" ] && emulate -L sh
	StripVars
	ColorVars
	IndirectVars
}

if [ -n "${config_file}" ]
then	PATH="${PATH}${PATH:+:}/usr/local/etc:/etc:" . "${config_file}"
fi

case "${maxlen:-x}" in
*[!0-9]*)
	maxlen=0
;;
esac

if ${zsh}
then	zsh_readable=${readable}
else	zsh_readable=false
	skipstatus=:
fi

if ! ${readable}
then	bash_escape="${zsh_escape}"
	bash_charseven="${zsh_charseven}"
elif ${zsh}
then	zsh_escape='${escape}'
	zsh_charseven='${charseven}'
	zsh_backslash='${backslash}'
fi

HandleVars

if [ "${extra_text:+set}" = set ]
then	separator="${extra_text}"
fi

if [ -z "${SSH_TTY}${SSH_CONNECTION}" ]
then	col_host="${col_host_normal}"
else	col_host="${col_host_ssh}"
fi

if [ -z "${softstatus}" ]
then	softstatus=false
	case "${TERM}" in
	screen*)
		softstatus=:
	;;
	esac
fi

if [ -z "${hardstatus}" ]
then	hardstatus=false
	case "${TERM}" in
	xterm*|screen*|rxvt*|aterm*|konsole*|gnome*|Eterm*|kterm*|interix*)
		hardstatus=:
	;;
	esac
fi

if [ ${maxlen} -gt 0 ]
then	statusdir='${d}'
	ps_dir='${c}'
else	statusdir="${ps_dir}"
fi

ps=''
if ${hardstatus} || ${softstatus}
then	status_both="${ps_user}${text_at}${ps_host}${extra_text}${statusdir}"
	if ${softstatus}
	then	ps="${ps}${startsstatus}${status_both}"
		${skipstatus} || ps="${ps}${sstatus_status}"
		ps="${ps}${endsstatus}"
	fi
	if ${hardstatus}
	then	ps="${ps}${starthstatus}${status_both}"
		${skipstatus} || ps="${ps}${hstatus_status}"
		ps="${ps}${endhstatus}"
	fi
fi

if [ -n "${ps}" ]
then	ps="${ps_open}${ps}${color_user}${ps_close}"
else	ps="${col_user}"
fi

ps="${ps}${ps_user}${col_at}${text_at}${col_host}${ps_host}"
ps="${ps}${col_separator}${separator}${col_dir}${ps_dir}"
${skipstatus} || ps="${ps}${ps_status}"
if ${vcs}
then	ps="${ps}\${VCSBRANCH:+\"${col_vcsbranchsep}${text_vcsbranchsep}"
	ps="${ps}${col_vcsbranch}\${VCSBRANCH}${col_vcsend}\"}"
	ps="${ps}\${VCSSTATUS:+\"${col_vcsstatussep}${text_vcsstatussep}"
	ps="${ps}${col_vcsstatus}\${VCSSTATUS}${col_vcsend}\"}"
fi
ps="${ps}${col_prompt}${ps_prompt}${col_trail}${text_trail}${col_endall}"
if [ ${maxlen} -gt 0 ]
then	[ ${maxlen} -gt ${#text_dots} ] || maxlen=${#text_dots}
	case "${leftkeep:-x}" in
	*[!0-9]*)
		leftkeep=0
	;;
	esac
	leftmax=$(( ${maxlen} - ${#text_dots} ))
	[ ${leftkeep} -le ${leftmax} ] || leftkeep=${leftmax}
	rightkeep=$(( ${maxlen} - ${leftkeep} - ${#text_dots} ))
	d2=''
	d3=''
	if ${zsh}
	then	d1='d="$(print -P '\''%~'\'')"'
		if [ ${leftkeep} -eq 1 ]
		then	d2='${d[1]}'
		elif [ ${leftkeep} -gt 1 ]
		then	d2='${d[1,'"${leftkeep}"']}'
		fi
		if [ ${rightkeep} -gt 0 ]
		then	rightkeep=$(( ${rightkeep} - 1 ))
			if [ ${rightkeep} -eq 0 ]
			then	d3='${d[${#d}]}'
			else	d3='${d[${#d}-'"${rightkeep}"',${#d}]}'
			fi
		fi
	else	d1='d="${PWD#~}"
[ "${d}" = "${PWD}" ] || d="~${d}"'
		[ ${leftkeep} -le 0 ] || d2='${d:0:'"${leftkeep}"'}'
		[ ${rightkeep} -le 0 ] || d3='${d: -'"${rightkeep}"'}'
	fi
	ps="\$(${d1}
if [ \${#d} -le ${maxlen} ]
then	c=\"\${d}\"
else	c=\"${d2}${col_dots}${text_dots}${col_dir}${d3}\"
	d=\"${d2}${text_dots}${d3}\"
fi
printf '%s' \"${ps}\")"
fi
Echon "${ps}"
